<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ghost Share ‚Äî P2P File Transfer</title>

    <!-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
     ‚ïë  SCRIPTS ARE AT THE BOTTOM OF <body> ‚Äî NOT HERE.        ‚ïë
     ‚ïë  If scripts are in <head>, the DOM elements don't exist  ‚ïë
     ‚ïë  yet when JS runs ‚Üí "cannot read property of null".      ‚ïë
     ‚ïë  Loading at bottom = DOM fully parsed first.             ‚ïë
     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù -->

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet" />

    <style>
        :root {
            --violet: #7B5CF6;
            --violet-dim: rgba(123, 92, 246, 0.15);
            --cyan: #06B6D4;
            --cyan-dim: rgba(6, 182, 212, 0.15);
            --bg: #030610;
            --surface: rgba(255, 255, 255, 0.028);
            --border: rgba(255, 255, 255, 0.07);
            --border-glow: rgba(123, 92, 246, 0.35);
            --text-muted: rgba(255, 255, 255, 0.38);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background:
                radial-gradient(ellipse 60% 50% at 15% 40%, rgba(123, 92, 246, 0.12) 0%, transparent 70%),
                radial-gradient(ellipse 50% 60% at 85% 20%, rgba(6, 182, 212, 0.08) 0%, transparent 65%),
                radial-gradient(ellipse 40% 40% at 50% 90%, rgba(123, 92, 246, 0.06) 0%, transparent 60%);
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 48px 48px;
            mask-image: radial-gradient(ellipse at center, black 30%, transparent 80%);
        }

        /* ‚îÄ‚îÄ GLASS ‚îÄ‚îÄ */
        .glass {
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.035);
            border: 1px solid var(--border);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 16px;
            transition: border-color 0.3s;
        }

        .glass-card:hover {
            border-color: var(--border-glow);
        }

        /* ‚îÄ‚îÄ BUTTONS ‚îÄ‚îÄ */
        .btn-primary {
            background: linear-gradient(135deg, #6d40f5 0%, #2563eb 100%);
            border: 1px solid rgba(109, 64, 245, 0.5);
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            color: #fff;
            transition: transform 0.2s, box-shadow 0.3s;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.12), transparent);
            transition: left 0.45s ease;
        }

        .btn-primary:hover::before {
            left: 100%;
        }

        .btn-primary:hover {
            box-shadow: 0 0 28px rgba(109, 64, 245, 0.55), 0 4px 20px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-ghost {
            background: rgba(255, 255, 255, 0.045);
            border: 1px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
            color: #fff;
            transition: background 0.2s, border-color 0.2s;
        }

        .btn-ghost:hover {
            background: rgba(255, 255, 255, 0.07);
            border-color: rgba(255, 255, 255, 0.14);
        }

        /* ‚îÄ‚îÄ TYPOGRAPHY ‚îÄ‚îÄ */
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }

        .label {
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        /* ‚îÄ‚îÄ FORMS ‚îÄ‚îÄ */
        textarea,
        input[type="text"],
        input[type="url"] {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            color: rgba(255, 255, 255, 0.8);
            outline: none;
            border-radius: 10px;
            transition: border-color 0.25s, box-shadow 0.25s;
            resize: none;
        }

        textarea:focus,
        input:focus {
            border-color: rgba(123, 92, 246, 0.5);
            box-shadow: 0 0 0 3px rgba(123, 92, 246, 0.1);
        }

        textarea::placeholder,
        input::placeholder {
            color: rgba(255, 255, 255, 0.2);
        }

        /* ‚îÄ‚îÄ SCREENS ‚îÄ‚îÄ */
        .screen {
            display: none;
            position: relative;
            z-index: 1;
        }

        .screen.active {
            display: block;
            animation: fadeUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes fadeUp {
            from {
                opacity: 0;
                transform: translateY(14px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ‚îÄ‚îÄ ANIMATIONS ‚îÄ‚îÄ */
        @keyframes logoPulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(123, 92, 246, 0.5);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(123, 92, 246, 0);
            }
        }

        .logo-icon {
            animation: logoPulse 3s ease-in-out infinite;
        }

        @keyframes connectedPulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.6);
            }

            50% {
                box-shadow: 0 0 0 5px rgba(34, 197, 94, 0);
            }
        }

        .conn-dot {
            animation: connectedPulse 2s ease-in-out infinite;
        }

        @keyframes activePulseRing {
            0% {
                transform: scale(0.85);
                opacity: 0.8;
            }

            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        @keyframes activePulseDot {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.12);
            }
        }

        .pulse-wrap {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pulse-ring-el {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            animation: activePulseRing 1.8s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        .pulse-core {
            animation: activePulseDot 2.2s ease-in-out infinite;
        }

        @keyframes floatY {

            0%,
            100% {
                transform: translateY(0) rotate(-2deg);
            }

            50% {
                transform: translateY(-8px) rotate(2deg);
            }
        }

        .float-icon {
            animation: floatY 4s ease-in-out infinite;
        }

        @keyframes barPulse {

            0%,
            100% {
                opacity: .8
            }

            50% {
                opacity: 1
            }
        }

        .speed-bar {
            animation: barPulse 1.1s ease-in-out infinite;
            border-radius: 3px 3px 0 0;
        }

        /* ‚îÄ‚îÄ PROGRESS RING ‚îÄ‚îÄ */
        .progress-ring-track {
            fill: none;
            stroke: rgba(255, 255, 255, 0.04);
            stroke-width: 7;
        }

        .progress-ring-fill {
            fill: none;
            stroke-width: 7;
            stroke: url(#ringGradient);
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.35s ease;
        }

        /* ‚îÄ‚îÄ DROP ZONE ‚îÄ‚îÄ */
        .drop-zone {
            border: 2px dashed rgba(123, 92, 246, 0.3);
            transition: all 0.3s;
            cursor: pointer;
        }

        .drop-zone:hover,
        .drop-zone.drag-active {
            border-color: rgba(123, 92, 246, 0.7);
            background: rgba(123, 92, 246, 0.04);
        }

        /* ‚îÄ‚îÄ STEP DOTS ‚îÄ‚îÄ */
        .step-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.12);
            transition: all 0.3s;
        }

        .step-dot.active {
            background: var(--violet);
            box-shadow: 0 0 8px rgba(123, 92, 246, 0.7);
        }

        /* ‚îÄ‚îÄ CONFIG PANEL ‚îÄ‚îÄ */
        .config-content {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .config-content.open {
            max-height: 600px;
        }

        /* ‚îÄ‚îÄ SCROLLBAR ‚îÄ‚îÄ */
        ::-webkit-scrollbar {
            width: 3px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(123, 92, 246, 0.4);
            border-radius: 2px;
        }

        /* ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ */
        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }

            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        #toast.visible {
            animation: toastIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* ‚îÄ‚îÄ BADGES ‚îÄ‚îÄ */
        .badge-violet {
            background: var(--violet-dim);
            border: 1px solid rgba(123, 92, 246, 0.25);
        }

        .badge-cyan {
            background: var(--cyan-dim);
            border: 1px solid rgba(6, 182, 212, 0.25);
        }
    </style>
</head>

<body>

    <!-- HEADER -->
    <header class="fixed top-0 left-0 right-0 z-50 flex items-center justify-between px-5 py-3"
        style="background:rgba(3,6,16,0.7);border-bottom:1px solid var(--border);backdrop-filter:blur(20px);">
        <div class="flex items-center gap-3">
            <div class="logo-icon w-8 h-8 rounded-xl flex items-center justify-center"
                style="background:linear-gradient(135deg,#7B5CF6,#2563eb);font-size:16px;">üëª</div>
            <span style="font-weight:700;font-size:15px;letter-spacing:-0.02em;">
                Ghost<span style="color:var(--violet);">Share</span>
            </span>
            <span class="mono" style="font-size:10px;color:rgba(255,255,255,0.2);">v2.0</span>
        </div>
        <div id="conn-badge" style="display:none;" class="items-center gap-2 px-3 py-1.5 rounded-full"
            style2="background:rgba(34,197,94,0.1);border:1px solid rgba(34,197,94,0.25);">
            <div class="conn-dot w-2 h-2 rounded-full" style="background:#22c55e;"></div>
            <span style="font-size:12px;font-weight:600;color:#22c55e;">Connected</span>
        </div>
    </header>

    <!-- MAIN -->
    <main
        style="padding-top:80px;padding-bottom:64px;padding-left:16px;padding-right:16px;max-width:640px;margin:0 auto;">

        <!-- ‚ïê‚ïê LANDING ‚ïê‚ïê -->
        <div id="screen-landing" class="screen active">
            <div class="text-center" style="padding:48px 0 32px;">
                <div class="inline-flex items-center gap-2 px-4 py-1.5 rounded-full mb-8"
                    style="background:rgba(255,255,255,0.04);border:1px solid var(--border);">
                    <span
                        style="width:6px;height:6px;border-radius:50%;background:var(--violet);display:inline-block;box-shadow:0 0 8px var(--violet);"></span>
                    <span style="font-size:12px;color:var(--text-muted);">Zero server ¬∑ Zero cloud ¬∑ Pure P2P</span>
                </div>
                <h1 style="font-size:52px;font-weight:800;letter-spacing:-0.04em;line-height:1.05;margin-bottom:16px;">
                    Ghost<span
                        style="background:linear-gradient(135deg,#a78bfa,#38bdf8);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">Share</span>
                </h1>
                <p style="color:var(--text-muted);font-size:16px;line-height:1.6;max-width:340px;margin:0 auto 48px;">
                    Browser-native encrypted P2P file transfer. WebRTC DataChannels.
                    No servers. No accounts. No file size limits.
                </p>

                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:40px;">
                    <button onclick="initSend()" class="glass-card text-left" style="padding:28px;cursor:pointer;">
                        <div
                            style="width:48px;height:48px;border-radius:16px;display:flex;align-items:center;justify-content:center;
                      margin-bottom:20px;background:rgba(123,92,246,0.15);border:1px solid rgba(123,92,246,0.2);font-size:22px;">
                            üì§</div>
                        <div style="font-size:17px;font-weight:700;margin-bottom:4px;">Send Files</div>
                        <div style="font-size:13px;color:var(--text-muted);line-height:1.5;">Create a session and beam
                            files to anyone</div>
                    </button>
                    <button onclick="initReceive()" class="glass-card text-left" style="padding:28px;cursor:pointer;">
                        <div
                            style="width:48px;height:48px;border-radius:16px;display:flex;align-items:center;justify-content:center;
                      margin-bottom:20px;background:rgba(6,182,212,0.12);border:1px solid rgba(6,182,212,0.2);font-size:22px;">
                            üì•</div>
                        <div style="font-size:17px;font-weight:700;margin-bottom:4px;">Receive Files</div>
                        <div style="font-size:13px;color:var(--text-muted);line-height:1.5;">Join a session and download
                            instantly</div>
                    </button>
                </div>

                <div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
                    <span class="badge-violet"
                        style="padding:6px 12px;border-radius:999px;font-size:11px;font-weight:500;">üîí DTLS
                        Encrypted</span>
                    <span class="badge-violet"
                        style="padding:6px 12px;border-radius:999px;font-size:11px;font-weight:500;">‚àû Unlimited
                        Size</span>
                    <span class="badge-cyan"
                        style="padding:6px 12px;border-radius:999px;font-size:11px;font-weight:500;">üì° Firewall
                        Bypass</span>
                    <span class="badge-cyan"
                        style="padding:6px 12px;border-radius:999px;font-size:11px;font-weight:500;">‚ö° Max
                        Throughput</span>
                </div>
            </div>
        </div>

        <!-- ‚ïê‚ïê SEND ‚ïê‚ïê -->
        <div id="screen-send" class="screen">
            <div style="display:flex;align-items:center;gap:12px;margin-top:16px;margin-bottom:24px;">
                <button onclick="goHome()" class="btn-ghost" style="padding:8px 14px;">‚Üê Back</button>
                <div>
                    <div style="font-size:17px;font-weight:700;">Send Files</div>
                    <div style="font-size:11px;color:var(--text-muted);">3-step handshake</div>
                </div>
                <div style="flex:1;"></div>
                <div style="display:flex;gap:6px;">
                    <div class="step-dot active" id="sdot-1"></div>
                    <div class="step-dot" id="sdot-2"></div>
                    <div class="step-dot" id="sdot-3"></div>
                </div>
            </div>

            <!-- STEP 1 -->
            <div id="s-step-1">
                <!-- Network Config -->
                <div class="glass-card" style="padding:0;overflow:hidden;margin-bottom:16px;">
                    <button onclick="toggleConf('s')" style="width:100%;display:flex;align-items:center;justify-content:space-between;
                       padding:14px 16px;cursor:pointer;background:transparent;border:none;color:#fff;">
                        <span
                            style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:500;color:rgba(255,255,255,0.65);">
                            üì° Network Config <span style="font-size:11px;color:var(--text-muted);">STUN / TURN</span>
                        </span>
                        <span id="chev-s"
                            style="transition:transform 0.3s;font-size:12px;color:var(--text-muted);">‚ñº</span>
                    </button>
                    <div class="config-content" id="conf-s">
                        <div style="padding:0 16px 16px;">
                            <div class="label" style="margin-bottom:8px;">Built-in STUN Servers</div>
                            <div class="mono glass"
                                style="font-size:10px;line-height:1.8;color:rgba(123,92,246,0.8);padding:12px;border-radius:10px;margin-bottom:16px;">
                                stun.l.google.com:19302<br />stun1.l.google.com:19302<br />stun.cloudflare.com:3478<br />stun.mozilla.com<br />stun.stunprotocol.org:3478<br />stun.nextcloud.com:443
                            </div>
                            <div class="label" style="margin-bottom:8px;">TURN Relay (for school/office firewalls)</div>
                            <input type="url" id="turn-url-s" placeholder="turn:openrelay.metered.ca:80"
                                style="width:100%;padding:10px 12px;margin-bottom:8px;" />
                            <div style="display:flex;gap:8px;">
                                <input type="text" id="turn-user-s" placeholder="username"
                                    style="flex:1;padding:10px 12px;" />
                                <input type="text" id="turn-pass-s" placeholder="password"
                                    style="flex:1;padding:10px 12px;" />
                            </div>
                            <p class="mono" style="font-size:10px;color:var(--text-muted);margin-top:8px;">Free:
                                openrelay.metered.ca ¬∑ relay.expressturn.com:3478</p>
                        </div>
                    </div>
                </div>

                <!-- Drop Zone -->
                <div id="drop-zone" class="drop-zone glass-card"
                    style="padding:40px;text-align:center;border-radius:20px;margin-bottom:16px;" onclick="pickFiles()"
                    ondragover="onDragOver(event)" ondragleave="onDragLeave(event)" ondrop="onDrop(event)">
                    <div class="float-icon" style="display:inline-block;margin-bottom:16px;font-size:40px;">üìÑ</div>
                    <div style="font-size:16px;font-weight:600;margin-bottom:6px;">Drop files or click to browse</div>
                    <div style="font-size:13px;color:var(--text-muted);">Any type ¬∑ Any size ¬∑ Multi-file auto-zipped
                    </div>
                    <input type="file" id="file-fallback" multiple style="display:none;"
                        onchange="onFileInput(this.files)" />
                </div>

                <!-- File list -->
                <div id="files-panel" style="display:none;" class="glass-card">
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px 16px 0;">
                        <div style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;">
                            üì¶ <span id="files-count-lbl">0 files</span>
                        </div>
                        <span class="mono" id="files-size-lbl" style="font-size:11px;color:var(--text-muted);"></span>
                    </div>
                    <div id="files-list" style="padding:12px 16px 16px;max-height:140px;overflow-y:auto;"></div>
                </div>

                <div style="margin-top:16px;">
                    <button id="btn-offer" onclick="createOffer()" disabled class="btn-primary"
                        style="width:100%;padding:14px 24px;font-size:15px;display:flex;align-items:center;justify-content:center;gap:8px;">
                        üì° Generate Connection Offer
                    </button>
                </div>
            </div>

            <!-- STEP 2 -->
            <div id="s-step-2" style="display:none;">
                <div class="glass-card" style="padding:16px;margin-bottom:16px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
                        <div class="label">üì∂ Your Offer Signal</div>
                        <button onclick="copyText('offer-out','Offer')" class="btn-ghost"
                            style="padding:6px 12px;font-size:12px;">üìã Copy</button>
                    </div>
                    <textarea id="offer-out" readonly rows="5" style="width:100%;padding:10px 12px;"></textarea>
                    <p style="font-size:11px;color:var(--text-muted);margin-top:8px;">Send this to the receiver via
                        chat, email, or QR below</p>
                </div>
                <div class="glass-card" style="padding:20px;margin-bottom:16px;text-align:center;">
                    <div class="label" style="margin-bottom:12px;">üî≤ QR Code (scan on mobile)</div>
                    <div id="qr-sender" style="display:flex;justify-content:center;"></div>
                    <p style="font-size:10px;color:var(--text-muted);margin-top:10px;">If QR is too large, use
                        copy-paste above</p>
                </div>
                <div class="glass-card" style="padding:16px;">
                    <div class="label" style="margin-bottom:12px;">üìé Paste Receiver's Answer</div>
                    <textarea id="answer-in" rows="5" placeholder="Paste the answer signal from the receiver..."
                        style="width:100%;padding:10px 12px;margin-bottom:12px;"></textarea>
                    <button onclick="applyAnswer()" class="btn-primary"
                        style="width:100%;padding:14px 24px;font-size:15px;display:flex;align-items:center;justify-content:center;gap:8px;">
                        üîó Connect &amp; Begin Transfer
                    </button>
                </div>
            </div>

            <!-- STEP 3 -->
            <div id="s-step-3" style="display:none;">
                <div id="sender-progress-area"></div>
            </div>
        </div><!-- /screen-send -->

        <!-- ‚ïê‚ïê RECEIVE ‚ïê‚ïê -->
        <div id="screen-receive" class="screen">
            <div style="display:flex;align-items:center;gap:12px;margin-top:16px;margin-bottom:24px;">
                <button onclick="goHome()" class="btn-ghost" style="padding:8px 14px;">‚Üê Back</button>
                <div>
                    <div style="font-size:17px;font-weight:700;">Receive Files</div>
                    <div style="font-size:11px;color:var(--text-muted);">2-step join handshake</div>
                </div>
                <div style="flex:1;"></div>
                <div style="display:flex;gap:6px;">
                    <div class="step-dot active" id="rdot-1"></div>
                    <div class="step-dot" id="rdot-2"></div>
                </div>
            </div>

            <!-- STEP 1 -->
            <div id="r-step-1">
                <div class="glass-card" style="padding:0;overflow:hidden;margin-bottom:16px;">
                    <button onclick="toggleConf('r')" style="width:100%;display:flex;align-items:center;justify-content:space-between;
                       padding:14px 16px;cursor:pointer;background:transparent;border:none;color:#fff;">
                        <span
                            style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:500;color:rgba(255,255,255,0.65);">
                            üì° Network Config <span style="font-size:11px;color:var(--text-muted);">optional TURN
                                relay</span>
                        </span>
                        <span id="chev-r"
                            style="transition:transform 0.3s;font-size:12px;color:var(--text-muted);">‚ñº</span>
                    </button>
                    <div class="config-content" id="conf-r">
                        <div style="padding:0 16px 16px;">
                            <div class="label" style="margin-bottom:8px;">TURN Relay</div>
                            <input type="url" id="turn-url-r" placeholder="turn:openrelay.metered.ca:80"
                                style="width:100%;padding:10px 12px;margin-bottom:8px;" />
                            <div style="display:flex;gap:8px;">
                                <input type="text" id="turn-user-r" placeholder="username"
                                    style="flex:1;padding:10px 12px;" />
                                <input type="text" id="turn-pass-r" placeholder="password"
                                    style="flex:1;padding:10px 12px;" />
                            </div>
                        </div>
                    </div>
                </div>
                <div class="glass-card" style="padding:16px;margin-bottom:16px;">
                    <div class="label" style="margin-bottom:12px;">üìé Paste Sender's Offer Signal</div>
                    <textarea id="offer-in" rows="7" placeholder="Paste the offer signal from the sender..."
                        style="width:100%;padding:10px 12px;"></textarea>
                </div>
                <button onclick="createAnswer()" class="btn-primary"
                    style="width:100%;padding:14px 24px;font-size:15px;display:flex;align-items:center;justify-content:center;gap:8px;">
                    ‚Ü© Generate Answer
                </button>
            </div>

            <!-- STEP 2 -->
            <div id="r-step-2" style="display:none;">
                <div class="glass-card" style="padding:16px;margin-bottom:16px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
                        <div class="label">üì∂ Your Answer Signal</div>
                        <button onclick="copyText('answer-out','Answer')" class="btn-ghost"
                            style="padding:6px 12px;font-size:12px;">üìã Copy</button>
                    </div>
                    <textarea id="answer-out" readonly rows="5" style="width:100%;padding:10px 12px;"></textarea>
                    <p style="font-size:11px;color:var(--text-muted);margin-top:8px;">Send this back to the sender ‚Äî
                        they'll paste it to connect</p>
                </div>
                <div class="glass-card" style="padding:20px;margin-bottom:16px;text-align:center;">
                    <div class="label" style="margin-bottom:12px;">üî≤ QR Code</div>
                    <div id="qr-receiver" style="display:flex;justify-content:center;"></div>
                </div>
                <div id="recv-status-area">
                    <div id="recv-waiting" class="glass-card" style="padding:32px;text-align:center;">
                        <div class="pulse-wrap" style="width:64px;height:64px;margin:0 auto 20px;position:relative;">
                            <div class="pulse-ring-el"
                                style="background:rgba(6,182,212,0.15);inset:0;position:absolute;border-radius:50%;">
                            </div>
                            <div class="pulse-core"
                                style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;
                                           background:rgba(6,182,212,0.2);border:1px solid rgba(6,182,212,0.3);position:relative;z-index:1;font-size:18px;">
                                üì∂</div>
                        </div>
                        <div style="font-size:15px;font-weight:600;margin-bottom:6px;">Waiting for sender...</div>
                        <div style="font-size:13px;color:var(--text-muted);">Connection establishes automatically once
                            the sender pastes your answer</div>
                    </div>
                </div>
            </div>
        </div><!-- /screen-receive -->

    </main>

    <!-- TOAST -->
    <div id="toast" style="display:none;position:fixed;z-index:9999;bottom:24px;left:50%;transform:translateX(-50%);
     background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);
     backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
     padding:12px 16px;border-radius:12px;
     align-items:center;gap:10px;min-width:220px;max-width:380px;white-space:nowrap;">
        <span id="toast-icon-el" style="font-size:16px;"></span>
        <span id="toast-msg" style="font-size:13px;font-weight:500;"></span>
    </div>


    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     SCRIPTS ‚Äî all at the bottom of body so the DOM is ready.
     Load order: Tailwind (CSS) ‚Üí QRCode ‚Üí JSZip ‚Üí App script
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <!-- Tailwind (CDN warning is advisory only ‚Äî fine for a self-contained tool) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- QRCode.js ‚Äî pinned version, cdnjs is reliable and not blocked by tracking prevention -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" crossorigin="anonymous"
        onerror="console.error('[GhostShare:BOOT] QRCode CDN failed to load!')"></script>

    <!-- JSZip ‚Äî pinned on cdnjs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"
        onerror="console.error('[GhostShare:BOOT] JSZip CDN failed to load!')"></script>

    <!--
  Lucide Icons ‚Äî using jsDelivr with a pinned version.
  WHY jsDelivr INSTEAD OF unpkg?
    - unpkg can be slow / blocked by some corporate/school proxies.
    - jsDelivr has better global CDN coverage and is rarely blocked.
  WHY A PINNED VERSION (0.344.0)?
    - "@latest" resolves at request time ‚Üí different versions on different refreshes.
    - Pinned version is cached reliably by CDN edge nodes.
  NOTE: We don't rely on lucide in this version. All icons use emoji as fallbacks,
        so the app is 100% functional even if Lucide fails to load.
-->
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.344.0/dist/umd/lucide.min.js" crossorigin="anonymous"
        onerror="console.warn('[GhostShare:BOOT] Lucide CDN failed ‚Äî emoji fallbacks active, app still works fine')"></script>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     MAIN APPLICATION SCRIPT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <script>
        'use strict';

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DEBUG LOGGER
        //  Every function call, state change, and error goes through here.
        //  Format: [GhostShare:SECTION] +T.TTTs message [data]
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const _t0 = performance.now();
        function dbg(sec, msg, data) {
            const ts = ((performance.now() - _t0) / 1000).toFixed(3);
            data !== undefined
                ? console.log(`[GhostShare:${sec}] +${ts}s`, msg, data)
                : console.log(`[GhostShare:${sec}] +${ts}s`, msg);
        }
        function dbgWarn(sec, msg, data) {
            const ts = ((performance.now() - _t0) / 1000).toFixed(3);
            console.warn(`[GhostShare:${sec}] ‚ö† +${ts}s`, msg, data !== undefined ? data : '');
        }
        function dbgError(sec, msg, err) {
            const ts = ((performance.now() - _t0) / 1000).toFixed(3);
            console.error(`[GhostShare:${sec}] ‚úñ +${ts}s`, msg, err !== undefined ? err : '');
        }

        dbg('BOOT', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Ghost Share initializing ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        dbg('BOOT', 'Script eval started at document.readyState =', document.readyState);
        dbg('BOOT', 'User agent:', navigator.userAgent);
        dbg('BOOT', 'Window location origin:', window.location.origin);


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DEPENDENCY CHECKER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function checkDependencies() {
            dbg('DEPS', '--- Checking all dependencies ---');

            const deps = {
                'RTCPeerConnection (WebRTC)': typeof RTCPeerConnection !== 'undefined',
                'QRCode.js': typeof QRCode !== 'undefined',
                'JSZip': typeof JSZip !== 'undefined',
                'Lucide Icons': typeof lucide !== 'undefined',
                'File System Access API': typeof showOpenFilePicker !== 'undefined',
                'Clipboard API': !!navigator.clipboard,
                'navigator.mediaDevices': !!navigator.mediaDevices,
            };

            for (const [name, ok] of Object.entries(deps)) {
                if (ok) dbg('DEPS', `  ‚úî ${name}`);
                else dbgWarn('DEPS', `  ‚úò ${name} ‚Äî NOT available`);
            }

            // Critical deps check
            if (!deps['RTCPeerConnection (WebRTC)']) {
                dbgError('DEPS', 'CRITICAL: WebRTC not supported in this browser ‚Äî app cannot function');
                showToast('WebRTC not supported in this browser', '‚ùå', 'red');
            }
            if (!deps['JSZip']) {
                dbgWarn('DEPS', 'JSZip missing ‚Äî multi-file zipping will fail. Single-file transfer still works.');
            }
            if (!deps['QRCode.js']) {
                dbgWarn('DEPS', 'QRCode missing ‚Äî QR generation will be skipped. Copy-paste still works.');
            }

            // Try to call lucide.createIcons() if library loaded
            if (typeof lucide !== 'undefined') {
                dbg('DEPS', 'Lucide loaded ‚Äî version:', lucide.VERSION || 'unknown');
                try {
                    lucide.createIcons();
                    dbg('DEPS', 'lucide.createIcons() succeeded');
                } catch (e) {
                    dbgWarn('DEPS', 'lucide.createIcons() threw (non-critical):', e.message);
                }
            } else {
                dbgWarn('DEPS', 'Lucide not loaded ‚Äî all icons use emoji fallbacks (app fully functional)');
            }

            dbg('DEPS', '--- Dependency check complete ---');
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CONSTANTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        /**
         * CHUNK_SIZE: Each file is split into 64 KB pieces before sending.
         * Why 64 KB?
         *  - Keeps per-chunk RAM usage tiny (~64KB in memory at any moment)
         *  - Below the WebRTC DataChannel maximum message size on most browsers
         *  - Industry standard for browser P2P file transfer
         */
        const CHUNK_SIZE = 64 * 1024;   // 64 KB

        /**
         * BACKPRESSURE thresholds:
         *  HIGH_WATER_MARK = stop sending when send buffer exceeds 1 MB
         *  LOW_WATER_MARK  = resume when buffer drains back to 256 KB
         *
         *  Without backpressure: buffer grows unbounded ‚Üí browser tab crash on large files.
         *  With backpressure:    saturate the network perfectly, zero buffer overflow.
         */
        const HIGH_WATER_MARK = 1 * 1024 * 1024;   // 1 MB
        const LOW_WATER_MARK = 256 * 1024;         // 256 KB

        /**
         * STUN_SERVERS: Help each peer discover its public-facing IP and port.
         * 6 servers from 4 different providers for maximum reliability.
         * If ALL STUN fails (symmetric NAT, very strict firewall), the user's
         * TURN relay takes over ‚Äî TURN relays traffic through a server, guaranteeing
         * connectivity at the cost of some latency.
         */
        const STUN_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun.cloudflare.com:3478' },
            { urls: 'stun:stun.mozilla.com' },
            { urls: 'stun:stun.stunprotocol.org:3478' },
            { urls: 'stun:stun.nextcloud.com:443' },
        ];

        dbg('CONFIG', 'CHUNK_SIZE =', `${CHUNK_SIZE / 1024} KB`);
        dbg('CONFIG', 'HIGH_WATER_MARK =', `${HIGH_WATER_MARK / 1024} KB`);
        dbg('CONFIG', 'LOW_WATER_MARK =', `${LOW_WATER_MARK / 1024} KB`);
        dbg('CONFIG', 'STUN servers =', STUN_SERVERS.length);


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  GLOBAL STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let pc = null;   // RTCPeerConnection
        let dc = null;   // RTCDataChannel
        let isSender = false;
        let selectedFiles = [];     // File[] chosen by sender
        let totalBytes = 0;
        let sentBytes = 0;
        let recvBytes = 0;
        let xferStart = 0;
        let lastPerfTime = 0;
        let lastPerfBytes = 0;
        let speedWindow = [];     // rolling speed samples (bytes/s)
        let speedHistory = [];     // for bar chart
        let inMeta = null;   // metadata from sender: {name,size,mime,chunks}
        let inChunks = [];     // ArrayBuffer[] accumulating received binary data
        let elapsedTimer = null;

        dbg('STATE', 'All global variables initialized to defaults');


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DOM HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function $(id) {
            const el = document.getElementById(id);
            if (!el) dbgWarn('DOM', `getElementById("${id}") returned null ‚Äî element missing?`);
            return el;
        }
        function show(id) { const e = $(id); if (e) { e.style.display = ''; dbg('DOM', `show("${id}")`); } }
        function hide(id) { const e = $(id); if (e) { e.style.display = 'none'; dbg('DOM', `hide("${id}")`); } }
        function showFlex(id) { const e = $(id); if (e) { e.style.display = 'flex'; dbg('DOM', `showFlex("${id}")`); } }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  NAVIGATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function showScreen(id) {
            dbg('NAV', `showScreen("${id}")`);
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const t = $(id);
            if (t) { t.classList.add('active'); dbg('NAV', `Screen "${id}" is now active`); }
            else dbgError('NAV', `Screen "${id}" not found in DOM!`);
        }

        function goHome() {
            dbg('NAV', 'goHome() called');
            cleanup();
            showScreen('screen-landing');
            hide('conn-badge');
            dbg('NAV', 'Back on landing screen');
        }

        function initSend() {
            dbg('NAV', 'initSend() ‚Äî user selected SEND mode');
            isSender = true;
            showScreen('screen-send');
            resetSendUI();
        }

        function initReceive() {
            dbg('NAV', 'initReceive() ‚Äî user selected RECEIVE mode');
            isSender = false;
            showScreen('screen-receive');
            resetReceiveUI();
        }

        function resetSendUI() {
            dbg('UI', 'resetSendUI()');
            show('s-step-1'); hide('s-step-2'); hide('s-step-3');
            setStepDots(['sdot-1', 'sdot-2', 'sdot-3'], 0);
            const btn = $('btn-offer');
            if (btn) { btn.disabled = true; dbg('UI', 'btn-offer disabled (no files yet)'); }
            hide('files-panel');
            const fl = $('files-list');
            if (fl) fl.innerHTML = '';
            selectedFiles = [];
        }

        function resetReceiveUI() {
            dbg('UI', 'resetReceiveUI()');
            show('r-step-1'); hide('r-step-2');
            setStepDots(['rdot-1', 'rdot-2'], 0);
        }

        function setStepDots(ids, activeIdx) {
            dbg('UI', `setStepDots([${ids}], active=${activeIdx})`);
            ids.forEach((id, i) => {
                const el = $(id);
                if (!el) return;
                el.classList.toggle('active', i === activeIdx);
            });
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  NETWORK CONFIG PANEL
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function toggleConf(side) {
            dbg('UI', `toggleConf("${side}")`);
            const panel = $(`conf-${side}`);
            const chev = $(`chev-${side}`);
            if (!panel) return;
            const open = panel.classList.toggle('open');
            if (chev) chev.style.transform = open ? 'rotate(180deg)' : '';
            dbg('UI', `Config panel "${side}" is now ${open ? 'OPEN' : 'CLOSED'}`);
        }

        function buildIceConfig(side) {
            dbg('ICE', `buildIceConfig("${side}")`);
            const iceServers = [...STUN_SERVERS];

            const url = ($(`turn-url-${side}`)?.value || '').trim();
            const user = ($(`turn-user-${side}`)?.value || '').trim();
            const pass = ($(`turn-pass-${side}`)?.value || '').trim();

            if (url) {
                dbg('ICE', `User-supplied TURN server: ${url}`, { user: user || '(none)', pass: pass ? '***' : '(none)' });
                iceServers.push({ urls: url, username: user || undefined, credential: pass || undefined });
            } else {
                dbg('ICE', 'No TURN server provided ‚Äî STUN-only mode');
            }

            const cfg = { iceServers, iceCandidatePoolSize: 10 };
            dbg('ICE', `RTCConfiguration assembled with ${iceServers.length} ICE servers`);
            return cfg;
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  FILE SELECTION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function pickFiles() {
            dbg('FILES', 'pickFiles() called');
            const fsaAvailable = 'showOpenFilePicker' in window;
            dbg('FILES', `File System Access API available: ${fsaAvailable}`);

            if (fsaAvailable) {
                dbg('FILES', 'Using showOpenFilePicker() ‚Äî streams files without loading them into RAM');
                try {
                    const handles = await window.showOpenFilePicker({ multiple: true });
                    dbg('FILES', `User selected ${handles.length} file handle(s)`);
                    selectedFiles = await Promise.all(handles.map(h => h.getFile()));
                    dbg('FILES', 'Resolved handles ‚Üí Files:', selectedFiles.map(f => `${f.name}(${fmtBytes(f.size)})`));
                    renderFileList(selectedFiles);
                } catch (e) {
                    if (e.name === 'AbortError') {
                        dbg('FILES', 'User pressed Cancel in file picker (AbortError) ‚Äî no action');
                    } else {
                        dbgWarn('FILES', `showOpenFilePicker threw unexpected error: ${e.message} ‚Äî falling back to <input>`);
                        $('file-fallback').click();
                    }
                }
            } else {
                dbg('FILES', 'FSA not available ‚Äî triggering hidden <input type="file">');
                $('file-fallback').click();
            }
        }

        function onFileInput(fileList) {
            dbg('FILES', `onFileInput() ‚Äî <input> returned ${fileList.length} file(s)`);
            selectedFiles = Array.from(fileList);
            dbg('FILES', 'Files:', selectedFiles.map(f => `${f.name}(${fmtBytes(f.size)})`));
            renderFileList(selectedFiles);
        }

        function onDragOver(e) {
            e.preventDefault();
            dbg('FILES', 'onDragOver ‚Äî drag detected over drop zone');
            $('drop-zone')?.classList.add('drag-active');
        }

        function onDragLeave(e) {
            dbg('FILES', 'onDragLeave ‚Äî drag left drop zone');
            $('drop-zone')?.classList.remove('drag-active');
        }

        function onDrop(e) {
            e.preventDefault();
            dbg('FILES', 'onDrop fired!');
            $('drop-zone')?.classList.remove('drag-active');
            selectedFiles = Array.from(e.dataTransfer.files);
            dbg('FILES', `Dropped ${selectedFiles.length} file(s):`, selectedFiles.map(f => f.name));
            if (selectedFiles.length) renderFileList(selectedFiles);
            else dbgWarn('FILES', 'Drop event had no files');
        }

        function renderFileList(files) {
            dbg('UI', `renderFileList() ‚Äî ${files.length} file(s)`);
            if (!files.length) { dbgWarn('UI', 'renderFileList: empty array'); return; }

            const total = files.reduce((s, f) => s + f.size, 0);
            dbg('UI', `Total size: ${fmtBytes(total)}`);

            const countEl = $('files-count-lbl');
            const sizeEl = $('files-size-lbl');
            const listEl = $('files-list');
            const panel = $('files-panel');
            const btn = $('btn-offer');

            if (countEl) countEl.textContent = `${files.length} file${files.length > 1 ? 's' : ''}`;
            if (sizeEl) sizeEl.textContent = fmtBytes(total);
            if (listEl) listEl.innerHTML = files.map(f => `
    <div style="display:flex;align-items:center;gap:8px;font-size:12px;padding:3px 0;">
      <span>${fileEmoji(f.name)}</span>
      <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,0.65);">${escHtml(f.name)}</span>
      <span class="mono" style="color:var(--text-muted);">${fmtBytes(f.size)}</span>
    </div>`).join('');

            if (panel) { panel.style.display = 'block'; dbg('UI', 'files-panel shown'); }
            if (btn) { btn.disabled = false; dbg('UI', 'btn-offer ENABLED ‚Äî files selected'); }
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  WEBRTC SIGNALING ‚Äî FULL EXPLANATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        /**
         *  HOW COPY-PASTE SIGNALING WORKS:
         *
         *  Normal WebRTC uses a "signaling server" to relay SDP/ICE between peers.
         *  We replace the server with the USER copying JSON text between two tabs/devices.
         *
         *  STEP 1 ‚Äî SENDER generates an "Offer" SDP:
         *    - Creates RTCPeerConnection + DataChannel
         *    - Calls pc.createOffer() ‚Üí browser generates SDP (Session Description Protocol)
         *    - SDP describes: audio/video codecs, encryption keys, ICE candidates (network paths)
         *    - Sets it as localDescription
         *    - Waits for ICE gathering = 'complete' (all network paths found via STUN/TURN)
         *    - Encodes final SDP as JSON ‚Üí user copies it ‚Üí sends to receiver
         *
         *  STEP 2 ‚Äî RECEIVER processes Offer, generates "Answer":
         *    - Creates its own RTCPeerConnection
         *    - Sets sender's SDP as remoteDescription
         *    - Calls pc.createAnswer() ‚Üí generates its own SDP
         *    - Waits for its own ICE gathering
         *    - Encodes Answer as JSON ‚Üí user copies it ‚Üí sends back to sender
         *
         *  STEP 3 ‚Äî SENDER processes Answer:
         *    - Sets receiver's SDP as remoteDescription
         *    - Both peers now have each other's network paths
         *    - ICE negotiation begins automatically
         *    - DataChannel opens ‚Üí file transfer starts
         */

        // ‚îÄ‚îÄ CREATE OFFER (Sender) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function createOffer() {
            dbg('SIGNAL', '‚ïê‚ïê createOffer() START ‚ïê‚ïê');
            if (!selectedFiles.length) {
                dbgWarn('SIGNAL', 'createOffer: no files selected ‚Äî aborting');
                showToast('Select files first', '‚ö†Ô∏è', 'red');
                return;
            }
            dbg('SIGNAL', `Files ready: ${selectedFiles.length}`);
            showToast('Generating offer...', '‚è≥', 'violet');

            dbg('SIGNAL', 'Creating RTCPeerConnection (sender)');
            const iceCfg = buildIceConfig('s');
            pc = new RTCPeerConnection(iceCfg);
            dbg('SIGNAL', 'pc created, signalingState:', pc.signalingState);

            /**
             * DataChannel must be created by the OFFERER (sender) before createOffer().
             * ordered:true = TCP-like delivery ‚Äî chunks arrive in order, no duplicates.
             * This is CRITICAL for file integrity. Without ordering, chunks could arrive
             * out of sequence and the file would be corrupted.
             */
            dbg('SIGNAL', 'Creating DataChannel "ghost" with ordered:true');
            dc = pc.createDataChannel('ghost', { ordered: true });
            dbg('SIGNAL', 'DataChannel created, readyState:', dc.readyState);
            setupDataChannel(dc, 'sender');

            monitorPeer(pc, 'sender');

            dbg('SIGNAL', 'Calling pc.createOffer()...');
            const offer = await pc.createOffer();
            dbg('SIGNAL', `Offer SDP created ‚Äî type:"${offer.type}" length:${offer.sdp.length} chars`);

            dbg('SIGNAL', 'pc.setLocalDescription(offer)...');
            await pc.setLocalDescription(offer);
            dbg('SIGNAL', 'localDescription set, signalingState:', pc.signalingState);

            dbg('SIGNAL', `Waiting for ICE gathering... current state: "${pc.iceGatheringState}"`);
            await waitForIceDone(pc);
            dbg('SIGNAL', '‚úÖ ICE gathering complete');

            const signal = JSON.stringify({ type: 'offer', sdp: pc.localDescription.sdp });
            dbg('SIGNAL', `Offer JSON string length: ${signal.length} chars`);

            const el = $('offer-out');
            if (el) { el.value = signal; dbg('SIGNAL', 'Offer written to textarea'); }

            genQR('qr-sender', signal, '#7B5CF6');

            hide('s-step-1'); show('s-step-2');
            setStepDots(['sdot-1', 'sdot-2', 'sdot-3'], 1);
            showToast('Offer ready ‚Äî share with receiver!', '‚úÖ', 'green');
            dbg('SIGNAL', '‚ïê‚ïê createOffer() DONE ‚ïê‚ïê');
        }

        // ‚îÄ‚îÄ APPLY ANSWER (Sender) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function applyAnswer() {
            dbg('SIGNAL', '‚ïê‚ïê applyAnswer() START ‚ïê‚ïê');
            const raw = ($('answer-in')?.value || '').trim();
            dbg('SIGNAL', `Answer input: ${raw.length} chars`);

            if (!raw) {
                dbgWarn('SIGNAL', 'applyAnswer: textarea is empty');
                showToast('Paste the answer signal first', '‚ö†Ô∏è', 'red');
                return;
            }

            let sig;
            try {
                sig = JSON.parse(raw);
                dbg('SIGNAL', 'Answer JSON parsed OK, type:', sig.type);
            } catch (e) {
                dbgError('SIGNAL', 'JSON.parse failed on answer input:', e);
                showToast('Invalid signal ‚Äî check you pasted it correctly', '‚ùå', 'red');
                return;
            }

            if (!sig.sdp) {
                dbgError('SIGNAL', 'Parsed answer missing .sdp field:', sig);
                showToast('Answer signal malformed (no SDP)', '‚ùå', 'red');
                return;
            }

            try {
                dbg('SIGNAL', 'pc.setRemoteDescription(answer)... signalingState before:', pc.signalingState);
                await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: sig.sdp }));
                dbg('SIGNAL', '‚úÖ remoteDescription set, signalingState:', pc.signalingState);
                showToast('Connecting...', 'üîó', 'violet');
                dbg('SIGNAL', 'ICE negotiation will now proceed automatically');
            } catch (e) {
                dbgError('SIGNAL', 'setRemoteDescription(answer) threw:', e);
                showToast('Connection failed ‚Äî see console for details', '‚ùå', 'red');
            }
            dbg('SIGNAL', '‚ïê‚ïê applyAnswer() DONE ‚ïê‚ïê');
        }

        // ‚îÄ‚îÄ CREATE ANSWER (Receiver) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function createAnswer() {
            dbg('SIGNAL', '‚ïê‚ïê createAnswer() START ‚ïê‚ïê');
            const raw = ($('offer-in')?.value || '').trim();
            dbg('SIGNAL', `Offer input: ${raw.length} chars`);

            if (!raw) {
                dbgWarn('SIGNAL', 'createAnswer: textarea is empty');
                showToast('Paste the offer signal first', '‚ö†Ô∏è', 'red');
                return;
            }

            let sig;
            try {
                sig = JSON.parse(raw);
                dbg('SIGNAL', 'Offer JSON parsed OK, type:', sig.type);
            } catch (e) {
                dbgError('SIGNAL', 'JSON.parse failed on offer input:', e);
                showToast('Invalid offer signal ‚Äî check pasting', '‚ùå', 'red');
                return;
            }

            if (!sig.sdp) {
                dbgError('SIGNAL', 'Offer missing .sdp field');
                showToast('Offer malformed (no SDP)', '‚ùå', 'red');
                return;
            }

            try {
                dbg('SIGNAL', 'Creating RTCPeerConnection (receiver)');
                const iceCfg = buildIceConfig('r');
                pc = new RTCPeerConnection(iceCfg);
                dbg('SIGNAL', 'Receiver pc created, signalingState:', pc.signalingState);

                monitorPeer(pc, 'receiver');

                /**
                 * The RECEIVER never calls createDataChannel().
                 * Instead, it listens for ondatachannel ‚Äî the browser delivers the
                 * sender's DataChannel automatically once the SDP is negotiated.
                 */
                pc.ondatachannel = (evt) => {
                    dbg('SIGNAL', 'üîî ondatachannel fired on receiver');
                    dbg('SIGNAL', `  Channel label: "${evt.channel.label}" | readyState: ${evt.channel.readyState}`);
                    dc = evt.channel;
                    setupDataChannel(dc, 'receiver');
                };

                dbg('SIGNAL', 'pc.setRemoteDescription(offer)... signalingState before:', pc.signalingState);
                await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: sig.sdp }));
                dbg('SIGNAL', 'remoteDescription set, signalingState:', pc.signalingState);

                dbg('SIGNAL', 'pc.createAnswer()...');
                const answer = await pc.createAnswer();
                dbg('SIGNAL', `Answer SDP ‚Äî type:"${answer.type}" length:${answer.sdp.length}`);

                dbg('SIGNAL', 'pc.setLocalDescription(answer)...');
                await pc.setLocalDescription(answer);
                dbg('SIGNAL', 'localDescription set, signalingState:', pc.signalingState);

                dbg('SIGNAL', `Waiting for receiver ICE... current: "${pc.iceGatheringState}"`);
                await waitForIceDone(pc);
                dbg('SIGNAL', '‚úÖ Receiver ICE gathering complete');

                const signal = JSON.stringify({ type: 'answer', sdp: pc.localDescription.sdp });
                dbg('SIGNAL', `Answer JSON length: ${signal.length} chars`);

                const el = $('answer-out');
                if (el) { el.value = signal; dbg('SIGNAL', 'Answer written to textarea'); }

                genQR('qr-receiver', signal, '#06B6D4');

                hide('r-step-1'); show('r-step-2');
                setStepDots(['rdot-1', 'rdot-2'], 1);
                showToast('Answer ready ‚Äî send it to sender!', '‚úÖ', 'green');
                dbg('SIGNAL', '‚ïê‚ïê createAnswer() DONE ‚ïê‚ïê');

            } catch (e) {
                dbgError('SIGNAL', 'createAnswer() failed:', e);
                showToast('Failed to generate answer ‚Äî see console', '‚ùå', 'red');
            }
        }

        // ‚îÄ‚îÄ WAIT FOR ICE GATHERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function waitForIceDone(peerConn) {
            dbg('ICE', `waitForIceDone() ‚Äî initial state: "${peerConn.iceGatheringState}"`);
            return new Promise(resolve => {
                if (peerConn.iceGatheringState === 'complete') {
                    dbg('ICE', 'Already complete ‚Äî resolving immediately');
                    resolve(); return;
                }
                const handler = () => {
                    dbg('ICE', `iceGatheringState ‚Üí "${peerConn.iceGatheringState}"`);
                    if (peerConn.iceGatheringState === 'complete') {
                        peerConn.removeEventListener('icegatheringstatechange', handler);
                        dbg('ICE', '‚úÖ ICE gathering done ‚Äî resolving');
                        resolve();
                    }
                };
                peerConn.addEventListener('icegatheringstatechange', handler);
                // Safety net: 15s timeout in case gathering never completes
                setTimeout(() => {
                    dbgWarn('ICE', '15s timeout reached ‚Äî resolving waitForIceDone anyway (partial candidates)');
                    resolve();
                }, 15000);
            });
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DATACHANNEL SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function setupDataChannel(channel, role) {
            dbg('CHANNEL', `setupDataChannel() role="${role}" readyState="${channel.readyState}"`);

            /**
             * binaryType = 'arraybuffer':
             * Received binary data arrives as ArrayBuffer (synchronous, zero-copy view).
             * The alternative 'blob' would require async reading and is slower.
             * ArrayBuffer ‚Üí we can push it directly into our inChunks array.
             */
            channel.binaryType = 'arraybuffer';
            dbg('CHANNEL', 'binaryType set to "arraybuffer"');

            channel.onopen = () => {
                dbg('CHANNEL', `‚òÖ DataChannel OPEN ‚òÖ ‚Äî role="${role}" readyState="${channel.readyState}"`);
                dbg('CHANNEL', 'maxMessageSize:', channel.maxMessageSize ?? 'n/a (browser default)');

                // Show connected badge
                const badge = $('conn-badge');
                if (badge) {
                    badge.style.display = 'flex';
                    badge.style.background = 'rgba(34,197,94,0.1)';
                    badge.style.border = '1px solid rgba(34,197,94,0.25)';
                    dbg('UI', 'Connection badge shown in header');
                }

                if (role === 'sender') {
                    dbg('CHANNEL', 'Sender: channel open ‚Üí switching to Step 3, starting transfer');
                    hide('s-step-2'); show('s-step-3');
                    setStepDots(['sdot-1', 'sdot-2', 'sdot-3'], 2);
                    beginTransfer();
                } else {
                    dbg('CHANNEL', 'Receiver: channel open ‚Üí showing progress area (replacing wait state)');
                    const area = $('recv-status-area');
                    if (area) {
                        area.innerHTML = '<div id="recv-progress-area"></div>';
                        dbg('UI', 'recv-progress-area injected into DOM');
                    }
                }
            };

            channel.onclose = () => {
                dbgWarn('CHANNEL', `DataChannel CLOSED ‚Äî role="${role}"`);
                onDisconnect();
            };

            channel.onerror = (e) => {
                dbgError('CHANNEL', `DataChannel ERROR ‚Äî role="${role}"`, e);
                onDisconnect();
            };

            if (role === 'receiver') {
                dbg('CHANNEL', 'Attaching onmessage handler for receiver');
                channel.onmessage = (evt) => {
                    const isString = typeof evt.data === 'string';
                    if (isString) {
                        dbg('RECV', `String msg received, length=${evt.data.length}`);
                    } else {
                        if (inChunks.length % 64 === 0) {
                            dbg('RECV', `Binary chunk #${inChunks.length} ‚Äî ${fmtBytes(evt.data.byteLength)} | total so far: ${fmtBytes(recvBytes)}`);
                        }
                    }
                    handleIncoming(evt.data);
                };
            } else {
                dbg('CHANNEL', 'Sender role: onmessage not attached (sender only sends, never receives data back)');
            }
        }

        // ‚îÄ‚îÄ PEER CONNECTION MONITORING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function monitorPeer(peerConn, role) {
            dbg('PEER', `monitorPeer() ‚Äî role="${role}"`);

            peerConn.onconnectionstatechange = () => {
                const s = peerConn.connectionState;
                dbg('PEER', `connectionState ‚Üí "${s}"`);
                if (s === 'connected') dbg('PEER', '‚úÖ Peer connection ESTABLISHED');
                else if (s === 'failed') { dbgError('PEER', 'Connection FAILED'); onDisconnect(); }
                else if (s === 'disconnected') { dbgWarn('PEER', 'Connection DISCONNECTED'); onDisconnect(); }
                else if (s === 'closed') dbg('PEER', 'Connection closed (clean)');
            };

            peerConn.oniceconnectionstatechange = () => {
                const s = peerConn.iceConnectionState;
                dbg('ICE', `iceConnectionState ‚Üí "${s}"`);
                if (s === 'failed') {
                    dbgWarn('ICE', 'ICE FAILED ‚Äî calling restartIce()');
                    peerConn.restartIce?.();
                } else if (s === 'connected' || s === 'completed') {
                    dbg('ICE', `‚úÖ ICE ${s} ‚Äî direct P2P path active`);
                }
            };

            peerConn.onsignalingstatechange = () => {
                dbg('PEER', `signalingState ‚Üí "${peerConn.signalingState}"`);
            };

            peerConn.onicecandidate = (evt) => {
                if (evt.candidate) {
                    dbg('ICE', `New candidate: type="${evt.candidate.type}" proto="${evt.candidate.protocol}" addr="${evt.candidate.address || 'hidden'}"`);
                } else {
                    dbg('ICE', 'End of ICE candidates (null candidate)');
                }
            };
        }

        function onDisconnect() {
            dbgWarn('PEER', 'onDisconnect() ‚Äî connection lost');
            clearInterval(elapsedTimer);
            const badge = $('conn-badge');
            if (badge) badge.style.display = 'none';
            showToast('Connection dropped ‚Äî refresh to retry', 'üì°', 'red');
            const statusEl = document.getElementById('xfer-status');
            if (statusEl) { statusEl.textContent = '‚ö† Disconnected'; statusEl.style.color = '#ef4444'; }
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  TRANSFER ENGINE ‚Äî SENDING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function beginTransfer() {
            dbg('XFER', '‚ïê‚ïê‚ïê‚ïê beginTransfer() START ‚ïê‚ïê‚ïê‚ïê');
            dbg('XFER', `Files: ${selectedFiles.length}`);
            selectedFiles.forEach((f, i) => dbg('XFER', `  [${i}] "${f.name}" ${fmtBytes(f.size)} ${f.type || 'unknown type'}`));

            let blob, name;

            if (selectedFiles.length === 1) {
                dbg('XFER', 'Single file ‚Äî sending directly (no zip needed)');
                blob = selectedFiles[0];
                name = selectedFiles[0].name;
            } else {
                dbg('XFER', `${selectedFiles.length} files ‚Äî bundling with JSZip (DEFLATE level 3)`);
                showToast('Zipping files...', 'üì¶', 'violet');

                if (typeof JSZip === 'undefined') {
                    dbgError('XFER', 'JSZip not loaded ‚Äî cannot zip multiple files!');
                    showToast('JSZip failed to load ‚Äî try refreshing', '‚ùå', 'red');
                    return;
                }

                const zip = new JSZip();
                for (const f of selectedFiles) {
                    dbg('XFER', `  zip.file("${f.name}")`);
                    zip.file(f.name, f, { binary: true });
                }

                dbg('XFER', 'Generating zip blob...');
                blob = await zip.generateAsync(
                    { type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 3 } },
                    (meta) => { if (meta.percent % 25 < 2) dbg('XFER', `Zip progress: ${meta.percent.toFixed(0)}%`); }
                );
                name = `ghost-share-${Date.now()}.zip`;
                dbg('XFER', `Zip done: "${name}" ${fmtBytes(blob.size)}`);
            }

            totalBytes = blob.size;
            sentBytes = 0;
            xferStart = performance.now();
            lastPerfTime = xferStart;
            lastPerfBytes = 0;
            speedWindow = [];
            speedHistory = [];

            const totalChunks = Math.ceil(totalBytes / CHUNK_SIZE);
            dbg('XFER', `totalBytes=${fmtBytes(totalBytes)} CHUNK_SIZE=${fmtBytes(CHUNK_SIZE)} totalChunks=${totalChunks}`);

            // ‚îÄ‚îÄ SEND META HEADER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            /**
             * We send a JSON string BEFORE any binary chunks.
             * This tells the receiver: filename, total size, MIME type, chunk count.
             * The receiver uses this to initialize its progress UI and inChunks buffer.
             */
            const meta = { type: 'meta', name, size: totalBytes, mime: blob.type || 'application/octet-stream', chunks: totalChunks };
            dbg('XFER', 'Sending META:', meta);
            dc.send(JSON.stringify(meta));

            renderProgressUI('sender-progress-area', name);

            /**
             * BACKPRESSURE SETUP:
             * bufferedAmountLowThreshold = the level at which 'bufferedamountlow' fires.
             * Set it to our LOW_WATER_MARK so we know exactly when to resume sending.
             */
            dc.bufferedAmountLowThreshold = LOW_WATER_MARK;
            dbg('XFER', `bufferedAmountLowThreshold = ${fmtBytes(LOW_WATER_MARK)}`);

            // ‚îÄ‚îÄ CHUNK SEND LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            /**
             * CHUNKING ‚Äî STEP BY STEP:
             *
             *  1. offset starts at 0.
             *  2. Each iteration:
             *     a. BACKPRESSURE: if dc.bufferedAmount > HIGH_WATER_MARK (1MB),
             *        PAUSE and await 'bufferedamountlow' event (buffer drained to 256KB).
             *     b. blob.slice(offset, offset+64KB): creates a lazy Blob view ‚Äî no data copied yet.
             *     c. await slice.arrayBuffer(): reads exactly those bytes from disk/memory.
             *     d. dc.send(buffer): sends raw ArrayBuffer (WebRTC DTLS encrypts it transparently).
             *     e. Increment offset and sentBytes.
             *  3. After the loop: send a JSON {"type":"done"} message to tell the receiver it's over.
             *
             *  MEMORY USAGE: at any moment, only ~1 chunk (64KB) + send buffer (‚â§1MB) in RAM.
             *  A 10GB file would use the same RAM as a 1MB file. Zero browser crash risk.
             */
            let offset = 0;
            let chunkIdx = 0;
            dbg('XFER', '--- Chunk loop starting ---');

            while (offset < totalBytes) {

                // ‚îÄ‚îÄ BACKPRESSURE GATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                /**
                 * dc.bufferedAmount = bytes queued in send buffer not yet sent.
                 * If this grows too large we'll exhaust memory and the browser tab will crash.
                 *
                 * HIGH_WATER_MARK (1MB): "buffer is getting full ‚Üí STOP"
                 * We await the 'bufferedamountlow' event which fires when it drains to
                 * LOW_WATER_MARK (256KB). Then we RESUME.
                 *
                 * This gives us maximum throughput because:
                 *  - We never send faster than the network can consume
                 *  - We never leave the network idle (buffer never fully drains before we resume)
                 */
                if (dc.bufferedAmount > HIGH_WATER_MARK) {
                    dbgWarn('XFER', `BACKPRESSURE: buffered=${fmtBytes(dc.bufferedAmount)} > HWM=${fmtBytes(HIGH_WATER_MARK)} ‚Üí PAUSING`);
                    await new Promise(resolve => {
                        dc.onbufferedamountlow = () => {
                            dbg('XFER', `BACKPRESSURE: bufferedamountlow fired ‚Äî buffered=${fmtBytes(dc.bufferedAmount)} ‚Üí RESUMING`);
                            dc.onbufferedamountlow = null;
                            resolve();
                        };
                    });
                }

                // Slice the next window (lazy ‚Äî no full-file read)
                const end = Math.min(offset + CHUNK_SIZE, totalBytes);
                const slice = blob.slice(offset, end);
                const buffer = await slice.arrayBuffer();  // reads exactly those bytes

                dc.send(buffer);  // raw binary ‚Üí DTLS encrypts it transparently

                offset += buffer.byteLength;
                sentBytes = offset;
                chunkIdx++;

                // Log progress every 64 chunks to avoid console spam
                if (chunkIdx % 64 === 0 || offset >= totalBytes) {
                    dbg('XFER', `Chunk ${chunkIdx}/${totalChunks} ‚Äî sent ${fmtBytes(sentBytes)}/${fmtBytes(totalBytes)} ‚Äî buffered: ${fmtBytes(dc.bufferedAmount)}`);
                }

                tickSpeed(sentBytes);
                updateRing(sentBytes / totalBytes);
            }

            dbg('XFER', '--- Chunk loop done ---');
            dbg('XFER', `Total chunks sent: ${chunkIdx} | Total bytes: ${fmtBytes(sentBytes)}`);
            dbg('XFER', 'Sending DONE signal to receiver');
            dc.send(JSON.stringify({ type: 'done' }));

            showToast('Transfer complete ‚úì', '‚úÖ', 'green');
            finishUI();
            dbg('XFER', '‚ïê‚ïê‚ïê‚ïê beginTransfer() DONE ‚ïê‚ïê‚ïê‚ïê');
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  TRANSFER ENGINE ‚Äî RECEIVING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function handleIncoming(data) {
            if (typeof data === 'string') {
                dbg('RECV', `String message: "${data.substring(0, 60)}${data.length > 60 ? '...' : ''}"`);
                let msg;
                try { msg = JSON.parse(data); }
                catch (e) { dbgError('RECV', 'JSON.parse failed:', e); return; }

                if (msg.type === 'meta') {
                    dbg('RECV', '‚ïê‚ïê‚ïê‚ïê META received ‚ïê‚ïê‚ïê‚ïê', msg);
                    inMeta = msg;
                    inChunks = [];
                    recvBytes = 0;
                    totalBytes = msg.size;
                    xferStart = performance.now();
                    lastPerfTime = xferStart;
                    lastPerfBytes = 0;
                    speedWindow = [];
                    speedHistory = [];
                    dbg('RECV', `Expecting "${msg.name}" | ${fmtBytes(msg.size)} | ${msg.chunks} chunks | MIME:${msg.mime}`);
                    renderProgressUI('recv-progress-area', msg.name);
                }

                if (msg.type === 'done') {
                    dbg('RECV', '‚ïê‚ïê‚ïê‚ïê DONE signal received ‚ïê‚ïê‚ïê‚ïê');
                    dbg('RECV', `chunks received: ${inChunks.length} | bytes: ${fmtBytes(recvBytes)} | expected: ${fmtBytes(totalBytes)}`);
                    assembleAndDownload();
                }

            } else if (data instanceof ArrayBuffer) {
                inChunks.push(data);
                recvBytes += data.byteLength;
                if (inChunks.length % 64 === 0) {
                    dbg('RECV', `Chunk #${inChunks.length} ‚Äî ${fmtBytes(data.byteLength)} | cumulative: ${fmtBytes(recvBytes)}`);
                }
                tickSpeed(recvBytes);
                updateRing(recvBytes / totalBytes);
            } else {
                dbgWarn('RECV', `Unknown message data type: ${typeof data}`);
            }
        }

        function assembleAndDownload() {
            dbg('RECV', 'assembleAndDownload()');
            dbg('RECV', `${inChunks.length} chunks ‚Üí Blob assembly`);

            if (recvBytes !== inMeta.size) {
                dbgWarn('RECV', `Size mismatch: got ${fmtBytes(recvBytes)} expected ${fmtBytes(inMeta.size)}`);
            }

            const blob = new Blob(inChunks, { type: inMeta.mime });
            dbg('RECV', `Blob: ${fmtBytes(blob.size)} type="${blob.type}"`);

            const url = URL.createObjectURL(blob);
            dbg('RECV', `Object URL: ${url}`);

            const a = document.createElement('a');
            a.href = url; a.download = inMeta.name;
            dbg('RECV', `Triggering download: "${inMeta.name}"`);
            a.click();

            setTimeout(() => { URL.revokeObjectURL(url); dbg('RECV', 'Object URL revoked'); }, 5000);

            inChunks = [];
            showToast(`Downloaded: ${inMeta.name}`, '‚úÖ', 'green');
            finishUI();
            dbg('RECV', 'assembleAndDownload() DONE');
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  PROGRESS UI ‚Äî RING + SPEEDOMETER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function renderProgressUI(containerId, filename) {
            dbg('UI', `renderProgressUI("${containerId}", "${filename}")`);
            const el = $(containerId);
            if (!el) { dbgError('UI', `Container "${containerId}" not in DOM`); return; }

            const circ = (2 * Math.PI * 44).toFixed(2);
            el.innerHTML = `
    <div class="glass-card" style="padding:20px;margin-bottom:16px;">
      <div style="display:flex;align-items:center;gap:20px;margin-bottom:20px;">
        <!-- Progress Ring SVG -->
        <div id="ring-wrap" style="position:relative;flex-shrink:0;width:104px;height:104px;">
          <svg width="104" height="104" viewBox="0 0 104 104">
            <defs>
              <linearGradient id="ringGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%"   stop-color="#7B5CF6"/>
                <stop offset="100%" stop-color="#2563eb"/>
              </linearGradient>
            </defs>
            <circle class="progress-ring-track" cx="52" cy="52" r="44"/>
            <circle id="ring-fill" class="progress-ring-fill" cx="52" cy="52" r="44"
                    stroke-dasharray="${circ}" stroke-dashoffset="${circ}"/>
          </svg>
          <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;">
            <span id="ring-pct" style="font-size:20px;font-weight:800;letter-spacing:-0.03em;">0%</span>
          </div>
        </div>
        <!-- Stats column -->
        <div style="flex:1;min-width:0;">
          <div id="xfer-filename" style="font-size:13px;font-weight:600;overflow:hidden;text-overflow:ellipsis;
                                          white-space:nowrap;color:rgba(255,255,255,0.75);margin-bottom:6px;">${escHtml(filename)}</div>
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px;">
            <div class="conn-dot" style="width:8px;height:8px;border-radius:50%;background:#22c55e;flex-shrink:0;"></div>
            <span id="xfer-status" style="font-size:12px;color:var(--text-muted);">Transferring...</span>
          </div>
          <div style="display:flex;align-items:baseline;gap:6px;">
            <span id="speed-val" style="font-family:'JetBrains Mono';font-size:28px;font-weight:700;color:var(--violet);line-height:1;">0.00</span>
            <span style="font-size:13px;color:var(--text-muted);">MB/s</span>
          </div>
          <div id="bytes-lbl" class="mono" style="font-size:11px;color:var(--text-muted);margin-top:4px;">0 B / ${fmtBytes(totalBytes)}</div>
        </div>
      </div>
      <!-- Speed bar chart -->
      <div class="label" style="margin-bottom:8px;">Live Throughput</div>
      <div id="speed-bars" style="display:flex;align-items:flex-end;gap:2px;height:40px;"></div>
      <!-- ETA row -->
      <div style="display:flex;justify-content:space-between;margin-top:12px;font-size:11px;color:var(--text-muted);">
        <span id="eta-lbl">Calculating...</span>
        <span id="elapsed-lbl">0.0s elapsed</span>
      </div>
    </div>
  `;

            dbg('UI', 'Progress UI rendered, starting elapsed timer');
            startElapsedTimer();
        }

        function startElapsedTimer() {
            clearInterval(elapsedTimer);
            dbg('UI', 'Elapsed timer started');
            elapsedTimer = setInterval(() => {
                const el = $('elapsed-lbl');
                if (el) el.textContent = `${((performance.now() - xferStart) / 1000).toFixed(1)}s elapsed`;
            }, 500);
        }

        function tickSpeed(bytes) {
            const now = performance.now();
            const dt = (now - lastPerfTime) / 1000;
            if (dt < 0.15) return; // throttle: max 1 sample per 150ms

            const rate = (bytes - lastPerfBytes) / dt;
            if (rate < 0) { dbgWarn('PERF', `Negative rate dt=${dt.toFixed(3)}s`); return; }

            speedWindow.push(rate);
            if (speedWindow.length > 10) speedWindow.shift();
            speedHistory.push(rate);
            if (speedHistory.length > 28) speedHistory.shift();

            lastPerfTime = now;
            lastPerfBytes = bytes;

            paintSpeed();
        }

        function paintSpeed() {
            const avg = speedWindow.reduce((a, b) => a + b, 0) / speedWindow.length;
            const mbps = avg / (1024 * 1024);

            const sv = $('speed-val');
            if (sv) sv.textContent = mbps.toFixed(2);

            const bytesNow = isSender ? sentBytes : recvBytes;
            const bl = $('bytes-lbl');
            if (bl) bl.textContent = `${fmtBytes(bytesNow)} / ${fmtBytes(totalBytes)}`;

            const eta = $('eta-lbl');
            if (eta && avg > 0) {
                const rem = totalBytes - bytesNow;
                const secs = rem / avg;
                eta.textContent = secs < 60 ? `~${secs.toFixed(0)}s remaining` : `~${(secs / 60).toFixed(1)}m remaining`;
            }

            // Speed bar chart
            const barsEl = $('speed-bars');
            if (!barsEl) return;
            const arr = speedHistory;
            const maxSpd = Math.max(...arr, 1);
            const pad = 28 - arr.length;
            barsEl.innerHTML = [
                ...Array(pad).fill(0), ...arr
            ].map(s => {
                const f = s / maxSpd;
                const h = Math.max(3, f * 38);
                const r = Math.round(73 + f * 95);
                const g = Math.round(40 + f * 20);
                const op = (0.3 + f * 0.7).toFixed(2);
                return `<div class="speed-bar" style="flex:1;height:${h.toFixed(1)}px;background:rgb(${r},${g},246);opacity:${op};"></div>`;
            }).join('');
        }

        function updateRing(pct) {
            const ring = $('ring-fill');
            const pctEl = $('ring-pct');
            if (!ring) return;

            const circ = 2 * Math.PI * 44;
            ring.style.strokeDashoffset = (circ * (1 - pct)).toFixed(2);

            // Dynamic glow intensity proportional to speed
            const avg = speedWindow.length ? speedWindow.reduce((a, b) => a + b, 0) / speedWindow.length : 0;
            const mbps = avg / (1024 * 1024);
            const glowPx = Math.min(3 + mbps * 1.2, 30);
            const glowOp = Math.min(0.4 + mbps * 0.04, 0.95).toFixed(2);
            const wrap = $('ring-wrap');
            if (wrap) wrap.style.filter = `drop-shadow(0 0 ${glowPx.toFixed(1)}px rgba(123,92,246,${glowOp}))`;

            if (pctEl) pctEl.textContent = `${Math.round(pct * 100)}%`;
        }

        function finishUI() {
            dbg('UI', 'finishUI()');
            clearInterval(elapsedTimer);
            updateRing(1);
            const s = $('xfer-status');
            if (s) { s.textContent = isSender ? '‚úì Transfer complete' : '‚úì Download complete'; s.style.color = '#22c55e'; }
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  QR CODE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function genQR(containerId, text, color) {
            dbg('QR', `genQR("${containerId}") color=${color} textLen=${text.length}`);
            const el = $(containerId);
            if (!el) { dbgError('QR', `Container "${containerId}" not found`); return; }
            el.innerHTML = '';

            if (typeof QRCode === 'undefined') {
                dbgError('QR', 'QRCode library not loaded');
                el.innerHTML = '<p style="font-size:11px;color:var(--text-muted);padding:20px;">QR lib failed ‚Äî use copy-paste</p>';
                return;
            }
            if (text.length > 2953) {
                dbgWarn('QR', `Text too long for QR (${text.length} > 2953) ‚Äî skipping`);
                el.innerHTML = '<p style="font-size:11px;color:var(--text-muted);padding:20px;">Signal too large for QR ‚Äî use copy-paste</p>';
                return;
            }
            try {
                new QRCode(el, { text, width: 180, height: 180, colorDark: color || '#7B5CF6', colorLight: '#030610', correctLevel: QRCode.CorrectLevel.M });
                dbg('QR', 'QR code generated successfully');
            } catch (e) {
                dbgError('QR', 'QRCode constructor threw:', e);
                el.innerHTML = '<p style="font-size:11px;color:var(--text-muted);padding:20px;">QR generation failed ‚Äî use copy-paste</p>';
            }
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CLEANUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function cleanup() {
            dbg('CLEANUP', 'cleanup() called');
            clearInterval(elapsedTimer);
            if (dc) { try { dc.close(); dbg('CLEANUP', 'dc.close() OK'); } catch (e) { dbgWarn('CLEANUP', 'dc.close() threw:', e.message); } dc = null; }
            if (pc) { try { pc.close(); dbg('CLEANUP', 'pc.close() OK'); } catch (e) { dbgWarn('CLEANUP', 'pc.close() threw:', e.message); } pc = null; }
            selectedFiles = []; inChunks = []; speedWindow = []; speedHistory = [];
            totalBytes = sentBytes = recvBytes = 0; inMeta = null;
            dbg('CLEANUP', 'All state reset to defaults');
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CLIPBOARD
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function copyText(id, label) {
            dbg('COPY', `copyText("${id}", "${label}")`);
            const el = $(id);
            const val = el?.value;
            if (!val) { dbgWarn('COPY', `"${id}" is empty`); return; }
            dbg('COPY', `Copying ${val.length} chars`);

            if (navigator.clipboard) {
                navigator.clipboard.writeText(val)
                    .then(() => { dbg('COPY', 'Clipboard API: OK'); showToast(`${label} copied!`, '‚úÖ', 'green'); })
                    .catch(err => {
                        dbgWarn('COPY', 'Clipboard API failed, using execCommand:', err.message);
                        el.select(); document.execCommand('copy');
                        showToast(`${label} copied! (fallback)`, '‚úÖ', 'green');
                    });
            } else {
                dbgWarn('COPY', 'navigator.clipboard unavailable ‚Äî execCommand fallback');
                el.select(); document.execCommand('copy');
                showToast(`${label} copied!`, '‚úÖ', 'green');
            }
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  TOAST
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let _toastTimer = null;
        function showToast(msg, icon, color) {
            dbg('TOAST', `showToast("${msg}", "${icon}", "${color}")`);
            const toast = $('toast');
            const iconEl = $('toast-icon-el');
            const msgEl = $('toast-msg');
            if (!toast) { dbgWarn('TOAST', 'toast element missing'); return; }
            if (iconEl) iconEl.textContent = icon || '‚Ñπ';
            if (msgEl) msgEl.textContent = msg;
            toast.style.display = 'flex';
            clearTimeout(_toastTimer);
            _toastTimer = setTimeout(() => { toast.style.display = 'none'; dbg('TOAST', 'auto-hidden'); }, 3500);
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  UTILITIES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function fmtBytes(b) {
            if (!b || b === 0) return '0 B';
            const u = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(b) / Math.log(1024));
            return `${(b / Math.pow(1024, i)).toFixed(i > 0 ? 1 : 0)} ${u[i]}`;
        }

        function escHtml(s) {
            return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }

        function fileEmoji(name) {
            const ext = (name.split('.').pop() || '').toLowerCase();
            return ({
                pdf: 'üìÑ', doc: 'üìù', docx: 'üìù', txt: 'üìù', md: 'üìù',
                jpg: 'üñº', jpeg: 'üñº', png: 'üñº', gif: 'üñº', webp: 'üñº', svg: 'üñº', avif: 'üñº',
                mp4: 'üé¨', mov: 'üé¨', mkv: 'üé¨', avi: 'üé¨', webm: 'üé¨',
                mp3: 'üéµ', wav: 'üéµ', flac: 'üéµ', aac: 'üéµ', ogg: 'üéµ',
                zip: 'üì¶', tar: 'üì¶', gz: 'üì¶', rar: 'üì¶', '7z': 'üì¶',
                js: 'üíª', ts: 'üíª', py: 'üíª', html: 'üíª', css: 'üíª', json: 'üíª',
                xlsx: 'üìä', csv: 'üìä', exe: '‚öô', dmg: '‚öô'
            }[ext] || 'üìÑ');
        }


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  BOOT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function boot() {
            dbg('BOOT', 'boot() called ‚Äî running startup checks');
            checkDependencies();
            showToast('Ghost Share ready üëª', 'üëª', 'violet');
            dbg('BOOT', '‚úÖ Ghost Share fully initialized');
        }

        // DOMContentLoaded fires once the HTML is parsed.
        // Since our script is at the bottom of <body>, the DOM is already ready,
        // but we attach the listener anyway as a safety net.
        if (document.readyState === 'loading') {
            dbg('BOOT', 'DOM still loading ‚Äî attaching DOMContentLoaded listener');
            document.addEventListener('DOMContentLoaded', boot);
        } else {
            dbg('BOOT', `DOM already "${document.readyState}" ‚Äî calling boot() directly`);
            boot();
        }

        dbg('BOOT', 'Script tag evaluation complete ‚Äî app ready');
    </script>
</body>

</html>
